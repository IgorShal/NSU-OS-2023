#include "unistd.h"
#include "stdio.h"
#include "stdlib.h"
#include "sys/types.h"
#include "sys/wait.h"

/*
fork(2)
  pid_t fork(void) - создаёт процесс-потомок копированием текущего процесса. 
    Наследует открытые дескрипторы и некоторые другие ограничения (uid, sid, pgid, gid)
    Наследуется всё адресное пространство. При этом используется парадигма copy-on-write, 
      то есть копирование памяти производится только перед первой попыткой записи (кроме сегментов, выделенных с флагом MAP_SHARED)
    В процессе-родителе возвращает PID созданного потомка, в потомке - 0

exec(3) - функции этого вида заменяют образ процесса на новый (переписывает TEXT, DATA, BSS и STACK), запуская тем самым какую-то другую программу.
  Из такого механизма запуска также следует то, что исполнение кода исходного процесса не продолжится после завершения вызванного exec
  все функции записываются как `exec(l/lp/le/v/vp/vpe)`. Первым аргументом всегда идёт путь до исполняемого файла, далее идут различия в зависимости от суффиксов
    - за аргументы, передаваемые вызываемому файлу, отвечают флаги:
      - l - аргументы идут через запятую (первый аргумент - имя исполняемого файла, последний - (char*)NULL)
      - v - аргументы передаются как указатель на char** (принцип тот же, что при передаче аргументов в main)
      - e - после аргументов передаются переменные окружения через char** envp (execve(char* path, char** args, char** envp))
    - p - вместо пути до исполняемого файла можно указывать его имя. Тогда файл будет искаться в директориях из PATH. Если имя начинается с "/", значит указывается путь и PATH будет игнорироваться
  
  Все описанные выше функции являются обёрткой над системным вызовом execve(2):
  int execve(char* filename, char** args, char** envp) - из описанных суффиксов значение аргументов должно быть ясно

wait(2) - системные вызовы из этой группы используются для того, чтобы в процессе-родителе дождаться изменения состояния процесса-потомка
  Возможные изменения: ребёнок прекратился, был остановлен или продолжен сигналом
  pid_t waitpid(pid_t pid, int* status, int options) - останавливает исполнения до момента изменения состояния потомка с ID pid.
    Возвращает pid_t процесса-потомка, который изменил своё состояние
    Значения pid:
      < -1 - любой процесс-потомок из PGID = |pid|
      -1 - любой потомок
      0 - любой потомок с таким же PGID, что и у текущего процесса
      > 0 - процесс с PID = pid
    options - побитовый набор флагов (то есть собираются через побитовое ИЛИ):
      WNOHANG - продолжится исполнение, если ни один процесс не завершился. При успешном исполнении вернёт 0
      WUNTRACED - ребёнок остановился (но не отслеживается через ptrace(2))
      WCONTINUED - ребёнок продолжил исполнение (получил сигнал SIGCONT)
    В аргумент int* status, если он не равен NULL, записывается состояние ребёнка, которое можно проверить макросами из wstat(2)

  pid_t wait(int* status) - останавливает исполнение до момента, пока любой из потомков процесса не завершится.
    Эквивалентное waitpid(-1, &status, 0)

  waitid() - более новый системный вызов, дающий больше контроля. Не очень актуален для наших задач.

  Выполнять wait в какой-либо из форм КРАЙНЕ ЖЕЛАТЕЛЬНО, так как иначе будут возникать процессы-зомби (см. блок про exit(2))

wstat(2) - (сейчас находится в разделе wait(2)) - набор макросов для проверки статуса, записанного в int status функций wait(2):
  WIFEXITED(status) - true, если процесс завершился нормально (через exit() либо return в main())
    WEXITSTATUS(status) - ТОЛЬКО ЕСЛИ WIFEXITED(status) - возвращает статус возврата, который хранится в 8 младших битах status
  WIFSIGNALED(status) - true, если процесс прекратился сигналом
    WIFSIGNALED(status) - ТОЛЬКО ЕСЛИ WIFSIGNALED(status)-  возвращает номер сигнала
    WCOREDUMP(status) - ТОЛЬКО ЕСЛИ WIFSIGNALED(status) - true, если ребёнок создал core-файл
  WIFSTOPPED(status) - true, если процесс был остановлен сигналом (возможно при опции WUNTRACED или ребёнок отслеживается через ptrace)
    WSTOPSIG(status) - ТОЛЬКО ЕСЛИ WIFSTOPPED(status), возвращает номер сигнала
  WIFCONTINUED(status) - true, если ребёнок продолжил исполнение после получения сигнала SIGCONT

ptrace(2) - *не очень относится к делу, но есть её упоминания

exit(3) 
void exit(int status) - вызывает завершение программы и возвращает код завершения status & 0377 родителю
  Все потоки ввода-вывода флашатся, все временные файлы удаляются.
  После завершения процесса, некоторая информация о нём остаётся в ядре (PID, статус заврешения, информация об использованных ресурсах), чтобы её мог получить родитель через wait(2).
  До момента вызова wait в родителе процесс будет в статусе зомби
    Если родитель сам завершился, то ребёнок будет прикреплён к процессу init, который вызовет wait для УбИйСтВа ЗоМбИ!!!

  atexit(3) - ...

  on_exit(3) - ...

_exit(2)

Сигналы
  Сигнал - число, сообщающее о внешнем событии или ошибке. Посылаются от процесса к процессу или от ядра к процессу.
  Получающий процесс обрабатывает сигнал по одному из сценариев:
  - SIG_DFL - реакция по умолчанию
  - SIG_IGN - игнорирует сигнал
  - адрес функции - указанная функция перехватит сигнал
*/

int main(int argc, char** argv, char** envp) {
  pid_t child = fork();
  int status;
  if (child == 0) {
    char* args[] = {"cat", "./test.txt", NULL};
    execve("/bin/cat", args, envp);
    exit(0);
  }
  waitpid(child, &status, 0);
  if (WIFEXITED(status))
    printf("\nI'm a parent!\n");    
  return 0;
}